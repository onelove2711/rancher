busybox
rancher/calico-cni:v3.13.4
rancher/calico-ctl:v3.13.4
rancher/calico-kube-controllers:v3.13.4
rancher/calico-node:v3.13.4
rancher/calico-pod2daemon-flexvol:v3.13.4
rancher/cluster-proportional-autoscaler:1.3.0
rancher/cluster-proportional-autoscaler:1.7.1
rancher/configmap-reload:v0.3.0-rancher2
rancher/coredns-coredns:1.3.1
rancher/coredns-coredns:1.6.2
rancher/coredns-coredns:1.6.3
rancher/coredns-coredns:1.6.5
rancher/coredns-coredns:1.6.9
rancher/coreos-configmap-reload:v0.0.1
rancher/coreos-etcd:v3.3.10-rancher1
rancher/coreos-etcd:v3.3.15-rancher1
rancher/coreos-etcd:v3.4.3-rancher1
rancher/coreos-flannel:v0.12.0
rancher/coreos-kube-state-metrics:v1.9.5
rancher/coreos-prometheus-config-reloader:v0.38.1
rancher/coreos-prometheus-operator:v0.38.1
rancher/flannel-cni:v0.3.0-rancher6
rancher/fluentd:v0.1.19
rancher/grafana-grafana:6.3.6
rancher/grafana-grafana:6.7.4
rancher/hyperkube:v1.15.12-rancher2
rancher/hyperkube:v1.16.10-rancher2
rancher/hyperkube:v1.17.6-rancher2
rancher/hyperkube:v1.18.3-rancher2
rancher/istio-citadel:1.4.9
rancher/istio-coredns-plugin:0.2-istio-1.1
rancher/istio-galley:1.4.9
rancher/istio-kubectl:1.1.5
rancher/istio-kubectl:1.4.6
rancher/istio-kubectl:1.4.9
rancher/istio-mixer:1.4.9
rancher/istio-node-agent-k8s:1.4.9
rancher/istio-pilot:1.4.9
rancher/istio-proxyv2:1.4.9
rancher/istio-sidecar_injector:1.4.9
rancher/jaegertracing-all-in-one:1.14
rancher/jenkins-jnlp-slave:3.35-4
rancher/jetstack-cert-manager-controller:v0.8.1
rancher/k3s-upgrade:v1.17.7-k3s1
rancher/k3s-upgrade:v1.18.4-k3s1
rancher/k8s-dns-dnsmasq-nanny:1.15.0
rancher/k8s-dns-dnsmasq-nanny:1.15.2
rancher/k8s-dns-kube-dns:1.15.0
rancher/k8s-dns-kube-dns:1.15.2
rancher/k8s-dns-node-cache:1.15.7
rancher/k8s-dns-sidecar:1.15.0
rancher/k8s-dns-sidecar:1.15.2
rancher/kiali-kiali:v1.15
rancher/klipper-helm:v0.2.3
rancher/klipper-helm:v0.2.5
rancher/klipper-lb:v0.1.2
rancher/kube-api-auth:v0.1.4
rancher/kubectl:v1.17.0
rancher/kubernetes-external-dns:v0.6.0
rancher/library-traefik:1.7.19
rancher/local-path-provisioner:v0.0.11
rancher/log-aggregator:v0.1.6
rancher/metrics-server:v0.3.3
rancher/metrics-server:v0.3.4
rancher/metrics-server:v0.3.6
rancher/minio-minio:RELEASE.2019-09-25T18-25-51Z
rancher/nginx-ingress-controller-defaultbackend:1.5-rancher1
rancher/nginx-ingress-controller:nginx-0.32.0-rancher1
rancher/nginx:1.17.4-alpine
rancher/opa-gatekeeper:v3.1.0-beta.7
rancher/openzipkin-zipkin:2.14.2
rancher/pause:3.1
rancher/pipeline-jenkins-server:v0.1.4
rancher/pipeline-tools:v0.1.14
rancher/plugins-docker:18.09
rancher/prom-alertmanager:v0.20.0
rancher/prom-node-exporter:v0.18.1
rancher/prom-prometheus:v2.12.0
rancher/prom-prometheus:v2.17.2
rancher/prometheus-auth:v0.2.0
rancher/pstauffer-curl:v1.0.3
rancher/rancher-agent:v2.4.5
rancher/rancher:v2.4.5
rancher/rke-tools:v0.1.58
rancher/security-scan:v0.1.11
rancher/sonobuoy-sonobuoy:v0.16.3
rancher/system-upgrade-controller:v0.4.0
rancher/thanos:v0.10.1
registry:2



==============================
#!/bin/bash
images="rancher-images.tar.gz"
list="rancher-images.txt"
windows_image_list=""
windows_versions="1903"
usage () {
    echo "USAGE: $0 [--images rancher-images.tar.gz] --registry my.registry.com:5000"
    echo "  [-l|--image-list path] text file with list of images; one image per line."
    echo "  [-i|--images path] tar.gz generated by docker save."
    echo "  [-r|--registry registry:port] target private registry:port."
    echo "  [--windows-image-list path] text file with list of images used in Windows. Windows image mirroring is skipped when this is empty"
    echo "  [--windows-versions version] Comma separated Windows versions. e.g., \"1809,1903\". (Default \"1903\")"
    echo "  [-h|--help] Usage message"
}

push_manifest () {
    export DOCKER_CLI_EXPERIMENTAL=enabled
    manifest_list=()
    for i in "${arch_list[@]}"
    do
        manifest_list+=("$1-${i}")
    done

    echo "Preparing manifest $1, list[${arch_list[@]}]"
    docker manifest create "$1" "${manifest_list[@]}" --amend
    docker manifest push "$1" --purge
}

while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
        -r|--registry)
        reg="$2"
        shift # past argument
        shift # past value
        ;;
        -l|--image-list)
        list="$2"
        shift # past argument
        shift # past value
        ;;
        -i|--images)
        images="$2"
        shift # past argument
        shift # past value
        ;;
        --windows-image-list)
        windows_image_list="$2"
        shift # past argument
        shift # past value
        ;;
        --windows-versions)
        windows_versions="$2"
        shift # past argument
        shift # past value
        ;;
        -h|--help)
        help="true"
        shift
        ;;
        *)
        usage
        exit 1
        ;;
    esac
done
if [[ -z $reg ]]; then
    usage
    exit 1
fi
if [[ $help ]]; then
    usage
    exit 0
fi

docker load --input ${images}

linux_images=()
while IFS= read -r i; do
    [ -z "${i}" ] && continue
    linux_images+=("${i}");
done < "${list}"

arch_list=()
if [[ -n "${windows_image_list}" ]]; then
    IFS=',' read -r -a versions <<< "$windows_versions"
    for version in "${versions[@]}"
    do
        arch_list+=("windows-${version}")
    done

    windows_images=()
    while IFS= read -r i; do
        [ -z "${i}" ] && continue
        windows_images+=("${i}")
    done < "${windows_image_list}"

    # use manifest to publish images only used in Windows
    for i in "${windows_images[@]}"; do
        if [[ ! " ${linux_images[@]}" =~ " ${i}" ]]; then
            case $i in
            */*)
                image_name="${reg}/${i}"
                ;;
            *)
                image_name="${reg}/rancher/${i}"
                ;;
            esac
            push_manifest "${image_name}"
        fi
    done
fi


arch_list+=("linux-amd64")
for i in "${linux_images[@]}"; do
    [ -z "${i}" ] && continue
    arch_suffix=""
    use_manifest=false
    if [[ (-n "${windows_image_list}") && " ${windows_images[@]}" =~ " ${i}" ]]; then
        # use manifest to publish images when it is used both in Linux and Windows
        use_manifest=true
        arch_suffix="-linux-amd64"
    fi
    case $i in
    */*)
        image_name="${reg}/${i}"
        ;;
    *)
        image_name="${reg}/rancher/${i}"
        ;;
    esac

    docker tag "${i}" "${image_name}${arch_suffix}"
    docker push "${image_name}${arch_suffix}"

    if $use_manifest; then
        push_manifest "${image_name}"
    fi
done
